---
title: TypeScript에서 Generic으로 type-safe하게 코딩하기
date: 2023-04-02
description: TypesScript에서 제공하는 Generic을 알아보기
thumbnail: https://creazilla-store.fra1.digitaloceanspaces.com/icons/3254474/typescript-icon-icon-md.png
---

## Generic

`<T>`와 같이 괄호 형식으로 나타낸다. 여기서 T는 전달된 유형(**type**)을 나타낸다.
그리고, 제네릭은 함수, 타입, 클래스 및 인터페이스에 적용할 수 있다.
제네릭의 유용함을 아래 예제를 통해 알아보자.

```typescript
const Minsup = {
  age: 24,
  height: 174,
  interests: ['front-end', 'Web development', 'XR'],
  location: 'Korea',
};

const pickObjectKeys = (obj, keys) => {
  const result = {};

  for (const key of keys) {
    if (key in obj) {
      result[key] = obj[key];
    }
  }

  return result;
};

console.log(pickObjectKeys(Minsup, ['height', 'location']));
// { height: 174, location: 'Korea', }
```

위 코드에서 `pickObjectKeys(obj, keys)`함수는 keys로서 property key를 전달하면, 전달한 `key`와 `value`를 갖고 새로운 객체를 return 한다.

하지만 위 함수는 `obj`에 전달되는 객체가 어떤 `key`를 갖는지는 직접 확인해야만 알 수 있고, 존재하지 않는 `key`를 전달하면, 빈 객체를 return하기 때문에, 잠재적인 버그가 될 수 있다.

그런데 `Generic`을 사용하면 개발자의 실수를 방지하고, **type-safe**한 코드를 작성할 수 있다. 아래 예제는 `Generic`으로 type-safe하게 리팩토링한 코드이다.

```typescript
const pickObjectKeys = <T extends object, K extends keyof T>(obj: T, keys: K[]) => {
  const result = {} as Pick<T, K>;

  for (const key of keys) {
    if (key in obj) {
      result[key] = obj[key];
    }
  }

  return result;
};
```

`<T extends object, K extends keyof T>`는 함수에 대한 두 가지 parameter type 선언을 의미한다.
여기서 `T`는 객체 타입이며, `K`는 `T` 객체의 `property key`(keyof T)로 제한된다.

```typescript
const result = {} as Pick<T, K>;
// Pick<T, K>는 T 타입에서 K 키만 포함하는 새로운 타입을 나타낸다.
```

이는 pickObjectKeys 함수에 제공된 인수에 기반하여 반환 타입을 강제함으로써, 함수가 필요한 특정 타입을 알기 전에도 타입 구조를 강제할 수 있는 유연성을 제공한다.
이는 Visual Studio Code와 같은 에디터나 IDE에서 함수를 사용할 때 더 나은 개발자 경험을 제공하며, 제공된 객체에 기반하여 `keys` parameter에 대해 아래와 같이 어떤 `key`를 전달할 수 있는지 확인할 수 있다.

이처럼 `Generic`은 개발자경험 향상과 더불어 개발자의 실수를 줄여줄 수 있다.
**TypeScript**의 최대 장점중 하나로 꼽히는 **코드 안전성**을 확보해 런타임 오류를 방지할 수 있고, 코드 자동 완성(IntelliSense)을 통해 개발 생산성을 높일 수 있는 좋은 도구이다.
